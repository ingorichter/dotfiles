#!/usr/bin/env bash
#
# git-worktree - Simplify git worktree creation and management
# Usage: git worktree <command> [options]
#
# Commands:
#   create <name> [branch]  Create a new worktree
#   list                    List all worktrees  
#   remove <name>          Remove a worktree
#   switch <name>          Switch to a worktree directory
#   clean                  Remove stale worktree references
#   help                   Show this help message
#
# Examples:
#   git worktree create feature-auth main
#   git worktree create hotfix-123
#   git worktree list
#   git worktree switch feature-auth
#   git worktree remove feature-auth
#   git worktree clean

set -euo pipefail

# --- Configuration ---
SCRIPT_NAME="git-worktree"
VERSION="1.0.0"
DEFAULT_BASE_BRANCH="main"

# --- Colors for output ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Helper Functions ---
log_info() {
    echo -e "${BLUE}ℹ${NC} $*"
}

log_success() {
    echo -e "${GREEN}✅${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
    echo -e "${RED}❌${NC} $*" >&2
}

show_help() {
    cat << EOF
${SCRIPT_NAME} v${VERSION}

USAGE:
    git worktree <command> [options]

COMMANDS:
    create <name> [branch]  Create a new worktree
                           - name: worktree directory name
                           - branch: source branch (default: ${DEFAULT_BASE_BRANCH})
    
    list                   List all worktrees with status
    
    remove <name>         Remove a worktree and its directory
                         - name: worktree directory name
    
    switch <name>         Switch to worktree directory (cd)
                         - name: worktree directory name
    
    clean                 Remove stale worktree references
    
    help                  Show this help message

EXAMPLES:
    # Create a new worktree for feature development
    git worktree create feature-auth main
    
    # Create worktree from current branch
    git worktree create hotfix-123
    
    # List all worktrees
    git worktree list
    
    # Switch to a worktree (generates cd command)
    git worktree switch feature-auth
    
    # Remove a worktree
    git worktree remove feature-auth
    
    # Clean up stale references
    git worktree clean

NOTES:
    - Worktrees are created as sibling directories: repo-name-worktree-name
    - New branches are automatically created if they don't exist
    - Use 'git worktree' directly for advanced operations
    
EOF
}

# --- Validation Functions ---
check_git_repo() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        log_error "Not inside a git repository"
        exit 1
    fi
}

check_git_worktree_support() {
    if ! git worktree --help &>/dev/null; then
        log_error "Git worktree command not available. Please upgrade Git to 2.5+"
        exit 1
    fi
}

validate_worktree_name() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        log_error "Worktree name cannot be empty"
        exit 1
    fi
    
    if [[ "$name" =~ [[:space:]] ]]; then
        log_error "Worktree name cannot contain spaces"
        exit 1
    fi
    
    if [[ "$name" =~ ^[.-] ]]; then
        log_error "Worktree name cannot start with . or -"
        exit 1
    fi
}

get_repo_root() {
    git rev-parse --show-toplevel
}

get_worktree_path() {
    local name="$1"
    local repo_root
    repo_root="$(get_repo_root)"
    local repo_name
    repo_name="$(basename "$repo_root")"
    local parent_dir
    parent_dir="$(dirname "$repo_root")"
    echo "${parent_dir}/${repo_name}-${name}"
}

worktree_exists() {
    local name="$1"
    local worktree_path
    worktree_path="$(get_worktree_path "$name")"
    
    # Check if directory exists and is a worktree
    [[ -d "$worktree_path" ]] && git worktree list | grep -q "$worktree_path"
}

branch_exists() {
    local branch="$1"
    git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null
}

remote_branch_exists() {
    local branch="$1"
    git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null
}

get_current_branch() {
    git rev-parse --abbrev-ref HEAD
}

# --- Core Functions ---
create_worktree() {
    local name="$1"
    local base_branch="${2:-$DEFAULT_BASE_BRANCH}"
    
    validate_worktree_name "$name"
    
    if worktree_exists "$name"; then
        log_error "Worktree '$name' already exists"
        exit 1
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path "$name")"
    
    log_info "Creating worktree '$name' at '$worktree_path'"
    
    # If base branch doesn't exist locally, try to fetch it
    if ! branch_exists "$base_branch"; then
        if remote_branch_exists "$base_branch"; then
            log_info "Base branch '$base_branch' not found locally, fetching from origin..."
            git fetch origin "$base_branch:$base_branch"
        else
            log_error "Base branch '$base_branch' does not exist locally or on origin"
            exit 1
        fi
    fi
    
    # Create the worktree with a new branch
    local new_branch="$name"
    
    # Check if branch with same name already exists
    if branch_exists "$new_branch"; then
        log_warning "Branch '$new_branch' already exists, creating worktree with existing branch"
        git worktree add "$worktree_path" "$new_branch"
    else
        log_info "Creating new branch '$new_branch' from '$base_branch'"
        git worktree add -b "$new_branch" "$worktree_path" "$base_branch"
    fi
    
    log_success "Worktree '$name' created successfully"
    log_info "To switch to the worktree: cd '$worktree_path'"
    log_info "Or use: git worktree switch $name"
}

list_worktrees() {
    log_info "Git worktrees:"
    echo
    
    # Get worktree list and format it nicely
    git worktree list --porcelain | awk '
    BEGIN { 
        print "PATH\t\t\t\tBRANCH\t\tSTATUS"
        print "----\t\t\t\t------\t\t------"
    }
    /^worktree / { 
        path = substr($0, 10)
        # Extract just the directory name for cleaner display
        gsub(/.*\//, "", path)
    }
    /^branch / { 
        branch = substr($0, 8)
        gsub(/refs\/heads\//, "", branch)
    }
    /^bare$/ { 
        status = "bare"
    }
    /^detached$/ { 
        status = "detached"
    }
    /^$/ { 
        if (path && branch) {
            printf "%-30s\t%-15s\t%s\n", path, branch, (status ? status : "normal")
        }
        path = branch = status = ""
    }
    END {
        if (path && branch) {
            printf "%-30s\t%-15s\t%s\n", path, branch, (status ? status : "normal")
        }
    }'
}

remove_worktree() {
    local name="$1"
    
    validate_worktree_name "$name"
    
    if ! worktree_exists "$name"; then
        log_error "Worktree '$name' does not exist"
        exit 1
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path "$name")"
    
    # Confirm removal
    echo -e "${YELLOW}⚠${NC} This will remove worktree '$name' at '$worktree_path'"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Removal cancelled"
        return 0
    fi
    
    log_info "Removing worktree '$name'..."
    
    # Remove the worktree
    git worktree remove "$worktree_path" --force
    
    log_success "Worktree '$name' removed successfully"
    
    # Ask if user wants to delete the branch too
    if branch_exists "$name"; then
        echo
        read -p "Also delete branch '$name'? (y/N): " -n 1 -r
        echo
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git branch -D "$name"
            log_success "Branch '$name' deleted"
        fi
    fi
}

switch_worktree() {
    local name="$1"
    
    validate_worktree_name "$name"
    
    if ! worktree_exists "$name"; then
        log_error "Worktree '$name' does not exist"
        log_info "Available worktrees:"
        list_worktrees
        exit 1
    fi
    
    local worktree_path
    worktree_path="$(get_worktree_path "$name")"
    
    # Since we can't change the parent shell's directory, show the command
    log_info "To switch to worktree '$name', run:"
    echo
    echo "    cd '$worktree_path'"
    echo
    log_info "Or copy and run this command:"
    echo "cd '$worktree_path'"
}

clean_worktrees() {
    log_info "Cleaning up stale worktree references..."
    
    # git worktree prune removes references to deleted worktrees
    git worktree prune --verbose
    
    log_success "Cleanup completed"
}

# --- Main Script Logic ---
main() {
    # Check prerequisites
    check_git_repo
    check_git_worktree_support
    
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        create)
            if [[ $# -eq 0 ]]; then
                log_error "create command requires a worktree name"
                echo "Usage: git worktree create <name> [base-branch]"
                exit 1
            fi
            create_worktree "$@"
            ;;
        list|ls)
            list_worktrees
            ;;
        remove|rm)
            if [[ $# -eq 0 ]]; then
                log_error "remove command requires a worktree name"
                echo "Usage: git worktree remove <name>"
                exit 1
            fi
            remove_worktree "$1"
            ;;
        switch|sw)
            if [[ $# -eq 0 ]]; then
                log_error "switch command requires a worktree name"
                echo "Usage: git worktree switch <name>"
                exit 1
            fi
            switch_worktree "$1"
            ;;
        clean)
            clean_worktrees
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"